name: Processar EPG
on:
  # Trigger manual via workflow_dispatch - MELHORADO para app Android
  workflow_dispatch:
    inputs:
      # Configura√ß√µes b√°sicas
      offset_seconds:
        description: 'Offset em segundos (pode ser negativo)'
        required: false
        default: '30'
        type: string
      force_update:
        description: 'For√ßar atualiza√ß√£o mesmo se j√° processado hoje'
        required: false
        default: false
        type: boolean
      
      # NOVOS INPUTS para app Android
      m3u_url:
        description: 'URL do ficheiro M3U do utilizador'
        required: false
        type: string
      user_config:
        description: 'JSON com configura√ß√µes do utilizador (matches, timeshift, etc.)'
        required: false
        type: string
      generate_user_config:
        description: 'Gerar ficheiro de configura√ß√£o personalizado'
        required: false
        default: false
        type: boolean

  # Trigger autom√°tico di√°rio √†s 06:00 UTC
  schedule:
    - cron: '0 6 * * *'

  # Trigger quando h√° push de ficheiros de configura√ß√£o na raiz
  push:
    paths:
      - '*.m3u'
      - '*.xml'
      - 'runworkflow'
      - 'config.json'
      - 'user_configs/*.json'  # NOVO: configs de utilizadores
    branches:
      - main

jobs:
  processar-epg:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests lxml python-dateutil
        
    - name: Verificar se processar.py existe
      run: |
        if [ ! -f "processar.py" ]; then
          echo "‚ùå Erro: processar.py n√£o encontrado!"
          exit 1
        fi
        echo "‚úÖ processar.py encontrado"
    
    # NOVO: Download do M3U do utilizador se fornecido
    - name: Download M3U do utilizador
      if: github.event.inputs.m3u_url != ''
      run: |
        echo "üì• Fazendo download do M3U do utilizador..."
        M3U_URL="${{ github.event.inputs.m3u_url }}"
        
        # Gerar nome do ficheiro baseado no timestamp
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        M3U_FILENAME="user_${TIMESTAMP}.m3u"
        
        # Download do M3U
        if curl -L -o "$M3U_FILENAME" "$M3U_URL"; then
          echo "‚úÖ M3U descarregado: $M3U_FILENAME"
          echo "M3U_FILE=$M3U_FILENAME" >> $GITHUB_ENV
        else
          echo "‚ùå Erro ao descarregar M3U de: $M3U_URL"
          exit 1
        fi
        
    # NOVO: Processar configura√ß√£o do utilizador
    - name: Processar configura√ß√£o do utilizador
      if: github.event.inputs.user_config != ''
      run: |
        echo "‚öôÔ∏è Processando configura√ß√£o do utilizador..."
        
        # Criar diret√≥rio para configs de utilizador
        mkdir -p user_configs
        
        # Salvar configura√ß√£o do utilizador
        echo '${{ github.event.inputs.user_config }}' > user_configs/temp_user_config.json
        
        # Validar JSON
        if python -c "import json; json.load(open('user_configs/temp_user_config.json'))"; then
          echo "‚úÖ Configura√ß√£o do utilizador v√°lida"
        else
          echo "‚ùå Configura√ß√£o do utilizador inv√°lida"
          exit 1
        fi
        
    - name: Determinar offset a usar
      id: offset
      run: |
        # Prioridade: 1) Input manual, 2) User config, 3) Arquivo config.json, 4) Padr√£o
        OFFSET="${{ github.event.inputs.offset_seconds }}"
        
        # Tentar obter do user config se n√£o fornecido
        if [ -z "$OFFSET" ] || [ "$OFFSET" = "" ]; then
          if [ -f "user_configs/temp_user_config.json" ]; then
            OFFSET=$(python -c "
import json
try:
    with open('user_configs/temp_user_config.json', 'r') as f:
        config = json.load(f)
    print(config.get('timeshift', {}).get('default_offset', 30))
except:
    print(30)
" 2>/dev/null || echo "30")
          fi
        fi
        
        # Fallback para config.json
        if [ -z "$OFFSET" ] || [ "$OFFSET" = "" ]; then
          if [ -f "config.json" ]; then
            OFFSET=$(python -c "
import json
try:
    with open('config.json', 'r') as f:
        config = json.load(f)
    print(config.get('offset_seconds', 30))
except:
    print(30)
" 2>/dev/null || echo "30")
          else
            OFFSET="30"
          fi
        fi
        
        echo "offset=$OFFSET" >> $GITHUB_OUTPUT
        echo "üéØ Offset determinado: $OFFSET segundos"

    - name: Verificar √∫ltima execu√ß√£o
      id: check_last_run
      run: |
        FORCE_UPDATE="${{ github.event.inputs.force_update }}"
        TODAY=$(date +%Y-%m-%d)
        SKIP_EXECUTION=false
        
        if [ -f "config.json" ] && [ "$FORCE_UPDATE" != "true" ]; then
          LAST_UPDATE=$(python -c "
import json
from datetime import datetime
try:
    with open('config.json', 'r') as f:
        config = json.load(f)
    last_update = config.get('last_update', '')
    if last_update:
        date_part = last_update.split('T')[0]
        print(date_part)
    else:
        print('')
except:
    print('')
" 2>/dev/null || echo "")
          
          if [ "$LAST_UPDATE" = "$TODAY" ]; then
            echo "‚è≠Ô∏è EPG j√° processado hoje ($TODAY). Use force_update=true para for√ßar."
            SKIP_EXECUTION=true
          fi
        fi
        
        echo "skip_execution=$SKIP_EXECUTION" >> $GITHUB_OUTPUT
        echo "last_update=$LAST_UPDATE" >> $GITHUB_OUTPUT

    - name: Executar processamento EPG
      if: steps.check_last_run.outputs.skip_execution != 'true'
      run: |
        echo "üöÄ Iniciando processamento EPG..."
        echo "‚è∞ Offset: ${{ steps.offset.outputs.offset }} segundos"
        echo "üìÖ Data/Hora: $(date)"
        
        # Executar o script principal
        python processar.py --offset ${{ steps.offset.outputs.offset }}
        
        # Verificar se os arquivos foram gerados
        if [ ! -f "compilacao.xml" ]; then
          echo "‚ùå Erro: compilacao.xml n√£o foi gerado!"
          exit 1
        fi
        
        if [ ! -f "compilacao.xml.gz" ]; then
          echo "‚ùå Erro: compilacao.xml.gz n√£o foi gerado!"
          exit 1
        fi
        
        # Mostrar informa√ß√µes dos arquivos gerados
        echo "‚úÖ Arquivos gerados com sucesso:"
        ls -lh compilacao.xml*
        
        # Verificar integridade do arquivo comprimido
        if ! gunzip -t compilacao.xml.gz; then
          echo "‚ùå Erro: compilacao.xml.gz est√° corrompido!"
          exit 1
        fi
        echo "‚úÖ Integridade do arquivo comprimido verificada"
        
    # MELHORADO: Processar match M3U com EPG (incluindo config do utilizador)
    - name: Processar match M3U com EPG
      if: steps.check_last_run.outputs.skip_execution != 'true'
      run: |
        # Procurar por arquivos M3U na raiz
        M3U_FILES=$(find . -maxdepth 1 -name "*.m3u" -type f)
        
        if [ -n "$M3U_FILES" ]; then
          echo "üì∫ Arquivos M3U encontrados para processamento:"
          echo "$M3U_FILES"
          
          # Criar backup dos M3U com timestamp
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          mkdir -p backups
          
          # Criar script Python MELHORADO para processar match M3U + EPG
          cat > processar_match_enhanced.py << 'EOF'
import re
import sys
import json
from lxml import etree
import os
from datetime import datetime

def carregar_config_utilizador():
    """Carrega configura√ß√£o do utilizador se existir"""
    config_path = "user_configs/temp_user_config.json"
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            pass
    return {}

def extrair_canais_m3u(arquivo_m3u):
    """Extrai canais do arquivo M3U"""
    canais = []
    try:
        with open(arquivo_m3u, 'r', encoding='utf-8') as f:
            conteudo = f.read()
        
        # Encontrar entradas EXTINF
        padrao = r'#EXTINF:.*?tvg-id="([^"]*)".*?tvg-name="([^"]*)".*?,(.*?)(?=\n[^#]|\nhttp|\n#|\Z)'
        matches = re.findall(padrao, conteudo, re.DOTALL | re.IGNORECASE)
        
        for tvg_id, tvg_name, nome_canal in matches:
            canal = {
                'tvg_id': tvg_id.strip(),
                'tvg_name': tvg_name.strip(),
                'nome': nome_canal.strip()
            }
            canais.append(canal)
        
        print(f"‚úÖ Extra√≠dos {len(canais)} canais do M3U")
        return canais
    except Exception as e:
        print(f"‚ùå Erro ao processar M3U: {e}")
        return []

def extrair_canais_epg(arquivo_xml):
    """Extrai IDs de canais do EPG"""
    try:
        tree = etree.parse(arquivo_xml)
        root = tree.getroot()
        
        canais_epg = {}
        for channel in root.findall('channel'):
            channel_id = channel.get('id', '')
            display_name = ''
            
            # Procurar display-name
            display_elem = channel.find('display-name')
            if display_elem is not None:
                display_name = display_elem.text or ''
            
            canais_epg[channel_id] = display_name.strip()
        
        print(f"‚úÖ Encontrados {len(canais_epg)} canais no EPG")
        return canais_epg
    except Exception as e:
        print(f"‚ùå Erro ao processar EPG: {e}")
        return {}

def aplicar_configuracao_utilizador(canais_m3u, user_config):
    """Aplica configura√ß√µes personalizadas do utilizador"""
    if not user_config:
        return canais_m3u
    
    # Aplicar matches manuais
    manual_matches = user_config.get('manual_matches', {})
    timeshift_configs = user_config.get('timeshift', {})
    
    for canal in canais_m3u:
        canal_nome = canal['nome']
        
        # Aplicar match manual se existir
        if canal_nome in manual_matches:
            canal['tvg_id'] = manual_matches[canal_nome]
            canal['manual_match'] = True
        
        # Aplicar timeshift personalizado
        if canal_nome in timeshift_configs:
            canal['timeshift'] = timeshift_configs[canal_nome]
    
    return canais_m3u

def criar_epg_personalizado(canais_m3u, canais_epg, arquivo_epg_original, arquivo_saida, user_config=None):
    """Cria EPG personalizado com apenas os canais da lista M3U"""
    try:
        # Parse do EPG original
        tree = etree.parse(arquivo_epg_original)
        root = tree.getroot()
        
        # IDs dos canais que queremos manter
        ids_desejados = set()
        matches_encontrados = 0
        
        # Aplicar configura√ß√µes do utilizador
        if user_config:
            canais_m3u = aplicar_configuracao_utilizador(canais_m3u, user_config)
        
        for canal_m3u in canais_m3u:
            tvg_id = canal_m3u['tvg_id']
            if tvg_id and tvg_id in canais_epg:
                ids_desejados.add(tvg_id)
                matches_encontrados += 1
        
        print(f"üéØ Matches encontrados: {matches_encontrados}/{len(canais_m3u)}")
        
        if not ids_desejados:
            print("‚ö†Ô∏è Nenhum match encontrado - mantendo EPG original")
            return False
        
        # Remover canais n√£o desejados
        for channel in root.findall('channel'):
            channel_id = channel.get('id', '')
            if channel_id not in ids_desejados:
                root.remove(channel)
        
        # Remover programas de canais n√£o desejados
        for programme in root.findall('programme'):
            channel_id = programme.get('channel', '')
            if channel_id not in ids_desejados:
                root.remove(programme)
        
        # Guardar EPG personalizado
        tree.write(arquivo_saida, encoding='utf-8', xml_declaration=True, pretty_print=True)
        
        # Verificar resultado
        canais_finais = len(root.findall('channel'))
        programas_finais = len(root.findall('programme'))
        
        print(f"‚úÖ EPG personalizado criado:")
        print(f"   - Canais: {canais_finais}")
        print(f"   - Programas: {programas_finais}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erro ao criar EPG personalizado: {e}")
        return False

def criar_ficheiro_configuracao_utilizador(canais_m3u, canais_epg, nome_ficheiro):
    """Cria ficheiro de configura√ß√£o final para o utilizador"""
    try:
        configuracao = {
            'generated_at': datetime.now().isoformat(),
            'total_channels': len(canais_m3u),
            'matched_channels': 0,
            'channels': [],
            'settings': {
                'timeshift': {},
                'manual_matches': {}
            }
        }
        
        for canal in canais_m3u:
            tvg_id = canal['tvg_id']
            matched = tvg_id in canais_epg if tvg_id else False
            
            if matched:
                configuracao['matched_channels'] += 1
            
            channel_config = {
                'name': canal['nome'],
                'tvg_id': tvg_id,
                'tvg_name': canal['tvg_name'],
                'matched': matched,
                'epg_display_name': canais_epg.get(tvg_id, '') if matched else '',
                'timeshift': canal.get('timeshift', 0),
                'manual_match': canal.get('manual_match', False)
            }
            
            configuracao['channels'].append(channel_config)
        
        # Salvar configura√ß√£o
        with open(nome_ficheiro, 'w', encoding='utf-8') as f:
            json.dump(configuracao, f, indent=2, ensure_ascii=False)
        
        print(f"‚úÖ Ficheiro de configura√ß√£o criado: {nome_ficheiro}")
        return True
        
    except Exception as e:
        print(f"‚ùå Erro ao criar ficheiro de configura√ß√£o: {e}")
        return False

# Processar cada arquivo M3U
if __name__ == "__main__":
    import glob
    
    # Carregar configura√ß√£o do utilizador
    user_config = carregar_config_utilizador()
    
    arquivos_m3u = glob.glob("*.m3u")
    epg_original = "compilacao.xml"
    
    if not os.path.exists(epg_original):
        print(f"‚ùå EPG original n√£o encontrado: {epg_original}")
        sys.exit(1)
    
    for arquivo_m3u in arquivos_m3u:
        print(f"\nüîÑ Processando: {arquivo_m3u}")
        
        # Extrair canais
        canais_m3u = extrair_canais_m3u(arquivo_m3u)
        if not canais_m3u:
            continue
        
        canais_epg = extrair_canais_epg(epg_original)
        if not canais_epg:
            continue
        
        # Nome do arquivo de sa√≠da baseado no M3U
        nome_base = os.path.splitext(arquivo_m3u)[0]
        arquivo_saida = f"{nome_base}_epg.xml"
        ficheiro_config = f"{nome_base}_config.json"
        
        # Criar EPG personalizado
        if criar_epg_personalizado(canais_m3u, canais_epg, epg_original, arquivo_saida, user_config):
            print(f"‚úÖ Criado: {arquivo_saida}")
        else:
            print(f"‚ùå Falha ao criar EPG para {arquivo_m3u}")
        
        # Criar ficheiro de configura√ß√£o do utilizador
        if criar_ficheiro_configuracao_utilizador(canais_m3u, canais_epg, ficheiro_config):
            print(f"‚úÖ Configura√ß√£o criada: {ficheiro_config}")
EOF

          # Executar processamento do match
          if [ -f "compilacao.xml" ]; then
            echo "üîÑ Executando match M3U + EPG..."
            python processar_match_enhanced.py
            
            # Criar backups ap√≥s processamento
            for m3u_file in $M3U_FILES; do
              if [ -f "$m3u_file" ]; then
                filename=$(basename "$m3u_file")
                cp "$m3u_file" "backups/${filename}_${TIMESTAMP}"
                echo "‚úÖ Backup criado: backups/${filename}_${TIMESTAMP}"
              fi
            done
          else
            echo "‚ö†Ô∏è compilacao.xml n√£o existe - pulando match"
          fi
          
          # Limpar script tempor√°rio
          rm -f processar_match_enhanced.py
        else
          echo "‚ÑπÔ∏è Nenhum arquivo M3U encontrado na raiz"
        fi

    - name: Remover arquivo runworkflow se existir
      if: steps.check_last_run.outputs.skip_execution != 'true'
      run: |
        if [ -f "runworkflow" ]; then
          echo "üóëÔ∏è Removendo arquivo trigger 'runworkflow'"
          rm runworkflow
        fi
        
    - name: Commit e push dos resultados
      if: steps.check_last_run.outputs.skip_execution != 'true'
      run: |
        # Configurar git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Adicionar arquivos gerados (incluindo EPGs e configs personalizados)
        git add compilacao.xml compilacao.xml.gz config.json
        git add *_epg.xml 2>/dev/null || true
        git add *_config.json 2>/dev/null || true  # NOVO: configs de utilizador
        git add user_configs/ 2>/dev/null || true  # NOVO: diret√≥rio de configs
        
        # Adicionar backups se existirem
        if [ -d "backups" ]; then
          git add backups/
        fi
        
        # Remover runworkflow do git se existir
        if git ls-files --error-unmatch runworkflow > /dev/null 2>&1; then
          git rm runworkflow
        fi
        
        # Verificar se h√° mudan√ßas para commit
        if git diff --staged --quiet; then
          echo "‚ÑπÔ∏è Nenhuma mudan√ßa para commit"
        else
          # Criar mensagem de commit informativa
          TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S UTC')
          OFFSET="${{ steps.offset.outputs.offset }}"
          
          USER_INFO=""
          if [ -n "${{ github.event.inputs.m3u_url }}" ]; then
            USER_INFO="üì± Processado via App Android"
          fi
          
          COMMIT_MSG="ü§ñ EPG processado automaticamente
üìÖ Data: $TIMESTAMP
‚è∞ Offset: ${OFFSET}s
üîÑ Trigger: ${{ github.event_name }}
$USER_INFO
üìä Status: ‚úÖ Sucesso"

          git commit -m "$COMMIT_MSG"
          git push
          echo "‚úÖ Resultados enviados para o reposit√≥rio"
        fi

    - name: Limpar arquivos tempor√°rios
      if: always()
      run: |
        # Remover arquivos tempor√°rios que possam ter sido criados
        rm -f origem.xml origem.xml.gz
        rm -f processar_match_enhanced.py
        echo "üßπ Limpeza conclu√≠da"
        
    - name: Mostrar resumo final
      if: steps.check_last_run.outputs.skip_execution != 'true'
      run: |
        echo "
        üìã RESUMO DA EXECU√á√ÉO
        ==================
        ‚úÖ Status: Processamento conclu√≠do com sucesso
        üìÖ Data/Hora: $(date)
        ‚è∞ Offset aplicado: ${{ steps.offset.outputs.offset }} segundos
        üîÑ Trigger: ${{ github.event_name }}
        üìÅ Arquivos gerados:
        $(ls -lh compilacao.xml* *_epg.xml *_config.json 2>/dev/null || echo '   Nenhum arquivo encontrado')
        
        üéâ EPG pronto para uso!
        "
        
    - name: Upload de artefatos (opcional)
      if: steps.check_last_run.outputs.skip_execution != 'true'
      uses: actions/upload-artifact@v4
      with:
        name: epg-compilado-${{ github.run_number }}
        path: |
          compilacao.xml
          compilacao.xml.gz
          config.json
          *_epg.xml
          *_config.json
        retention-days: 30

  # Job adicional para valida√ß√£o (opcional)
  validar-epg:
    needs: processar-epg
    runs-on: ubuntu-latest
    if: success()
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        pip install lxml
        
    - name: Validar XML gerado
      run: |
        if [ -f "compilacao.xml" ]; then
          echo "üîç Validando estrutura do XML..."
          
          python -c "
from lxml import etree
import sys

try:
    # Parse do XML
    tree = etree.parse('compilacao.xml')
    root = tree.getroot()
    
    # Contar elementos
    channels = len(root.findall('channel'))
    programmes = len(root.findall('programme'))
    
    print(f'‚úÖ XML v√°lido!')
    print(f'üì∫ Canais: {channels}')
    print(f'üìã Programas: {programmes}')
    
    if programmes == 0:
        print('‚ö†Ô∏è Aviso: Nenhum programa encontrado!')
        sys.exit(1)
    
    if channels == 0:
        print('‚ö†Ô∏è Aviso: Nenhum canal encontrado!')
        
    print('üéâ Valida√ß√£o conclu√≠da com sucesso!')
    
except Exception as e:
    print(f'‚ùå Erro na valida√ß√£o: {e}')
    sys.exit(1)
"
        else
          echo "‚ùå Arquivo compilacao.xml n√£o encontrado!"
          exit 1
        fi
